<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Silenceyixia_博客</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Silenceyixia_博客">
<meta property="og:url" content="http://silenceyixia.github.io/index.html">
<meta property="og:site_name" content="Silenceyixia_博客">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Silenceyixia_博客">
  
    <link rel="alternative" href="/atom.xml" title="Silenceyixia_博客" type="application/atom+xml">
  
  
    <link rel="icon" href="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">silenceyixia</a></h1>
		</hgroup>

		
		<p class="header-subtitle">android学习成长之路</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						<div class="icon-wrap icon-link hide" data-idx="2">
							<div class="loopback_l"></div>
							<div class="loopback_r"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						<li>友情链接</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/android-mediaplayer-视频-音频/" style="font-size: 10px;">android mediaplayer 视频 音频</a> <a href="/tags/java-设计模式/" style="font-size: 10px;">java 设计模式</a> <a href="/tags/标签-日常踩坑/" style="font-size: 10px;">标签:日常踩坑</a> <a href="/tags/标签-源码分析/" style="font-size: 20px;">标签:源码分析</a> <a href="/tags/标签：多线程/" style="font-size: 10px;">标签：多线程</a> <a href="/tags/标签：高德地图/" style="font-size: 10px;">标签：高德地图</a>
					</div>
				</section>
				
				
				
				<section class="switch-part switch-part3">
					<div id="js-friends">
					
			          <a target="_blank" class="main-nav-link switch-friends-link" href="https://github.com/smackgg/hexo-theme-smackdown">smackdown</a>
			        
			        </div>
				</section>
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">silenceyixia</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="http://7xkj1z.com1.z0.glb.clouddn.com/head.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">silenceyixia</h1>
			</hgroup>
			
			<p class="header-subtitle">android学习成长之路</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap">
  
    <article id="post-startActivityForResult方法踩坑" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/09/19/startActivityForResult方法踩坑/" class="article-date">
  	<time datetime="2018-09-19T09:28:12.000Z" itemprop="datePublished">2018-09-19</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/09/19/startActivityForResult方法踩坑/">
        startActivity()和startActivityForResult()
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>今天在写项目的时候碰到了一个以前没接触过的一个坑.具体是这样的：</p>
<p><strong>项目中有一块代码原本是内嵌在一个Fragment中，在这个碎片中使用到了startActivityForResult()方法，直接调用的是Fragment的<br>startActivityForResult()方法，是可以在onActivityResult()中拿到回调的。</strong></p>
<p><strong>然而新的需求中，在一个Fragment中的多样式列表中有一块内容和上面的Fragment中的列表样式一模一样，我想着将这一样的内容进行封<br>装使用，在使用的时候由于封装的那块代码是在Fragment中列表的字列表中调用的，就无法直接使用Fragment中<br>的startActivityForResult()，使用的是getActivity().startActivityForResult(),但是竟然没有在Fragment中<br>onActivityResult()拿到回调，于是我查看了源码发现：</strong></p>
<pre><code>Fragment.java中的startActivityForResult()是这样的：

/**
 * Call {@link Activity#startActivityForResult(Intent, int, Bundle)} from the fragment&apos;s
 * containing Activity.
 */
public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) {
    if (mHost == null) {
        throw new IllegalStateException(&quot;Fragment &quot; + this + &quot; not attached to Activity&quot;);
    }
    mHost.onStartActivityFromFragment(this /*fragment*/, intent, requestCode, options);
}

 /**
 * Called by Fragment.startActivityForResult() to implement its behavior.
 */
public void startActivityFromFragment(Fragment fragment, Intent intent,
        int requestCode, @Nullable Bundle options) {
    mStartedActivityFromFragment = true;
    try {
        if (requestCode == -1) {
            ActivityCompat.startActivityForResult(this, intent, -1, options);
            return;
        }
        checkForValidRequestCode(requestCode);
        int requestIndex = allocateRequestIndex(fragment);
        ActivityCompat.startActivityForResult(
                this, intent, ((requestIndex + 1) &lt;&lt; 16) + (requestCode &amp; 0xffff), options);
    } finally {
        mStartedActivityFromFragment = false;
    }
}

 public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,
        @Nullable Bundle options) {
    if (mParent == null) {
        options = transferSpringboardActivityOptions(options);
        Instrumentation.ActivityResult ar =
            mInstrumentation.execStartActivity(
                this, mMainThread.getApplicationThread(), mToken, this,
                intent, requestCode, options);
        if (ar != null) {
            mMainThread.sendActivityResult(
                mToken, mEmbeddedID, requestCode, ar.getResultCode(),
                ar.getResultData());
        }
        if (requestCode &gt;= 0) {
            // If this start is requesting a result, we can avoid making
            // the activity visible until the result is received.  Setting
            // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
            // activity hidden during this time, to avoid flickering.
            // This can only be done when a result is requested because
            // that guarantees we will get information back when the
            // activity is finished, no matter what happens to it.
            mStartedActivity = true;
        }

        cancelInputsAndStartExitTransition(options);
        // TODO Consider clearing/flushing other event sources and events for child windows.
    } else {
        if (options != null) {
            mParent.startActivityFromChild(this, intent, requestCode, options);
        } else {
            // Note we want to go through this method for compatibility with
            // existing applications that may have overridden it.
            mParent.startActivityFromChild(this, intent, requestCode);
        }
    }
}
</code></pre><hr>
<pre><code>Activity.java中的startActivityForResult()是这样的：

public void startActivityForResult(@RequiresPermission Intent intent, int requestCode,
        @Nullable Bundle options) {
    if (mParent == null) {
        options = transferSpringboardActivityOptions(options);
        Instrumentation.ActivityResult ar =
            mInstrumentation.execStartActivity(
                this, mMainThread.getApplicationThread(), mToken, this,
                intent, requestCode, options);
        if (ar != null) {
            mMainThread.sendActivityResult(
                mToken, mEmbeddedID, requestCode, ar.getResultCode(),
                ar.getResultData());
        }
        if (requestCode &gt;= 0) {
            // If this start is requesting a result, we can avoid making
            // the activity visible until the result is received.  Setting
            // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
            // activity hidden during this time, to avoid flickering.
            // This can only be done when a result is requested because
            // that guarantees we will get information back when the
            // activity is finished, no matter what happens to it.
            mStartedActivity = true;
        }

        cancelInputsAndStartExitTransition(options);
        // TODO Consider clearing/flushing other event sources and events for child windows.
    } else {
        if (options != null) {
            mParent.startActivityFromChild(this, intent, requestCode, options);
        } else {
            // Note we want to go through this method for compatibility with
            // existing applications that may have overridden it.
            mParent.startActivityFromChild(this, intent, requestCode);
        }
    }
}
</code></pre><p><strong>最终都会走ActivityThread.java中的</strong></p>
<pre><code> public final void sendActivityResult(
        IBinder token, String id, int requestCode,
        int resultCode, Intent data) {
    if (DEBUG_RESULTS) Slog.v(TAG, &quot;sendActivityResult: id=&quot; + id
            + &quot; req=&quot; + requestCode + &quot; res=&quot; + resultCode + &quot; data=&quot; + data);
    ArrayList&lt;ResultInfo&gt; list = new ArrayList&lt;ResultInfo&gt;();
    list.add(new ResultInfo(id, requestCode, resultCode, data));
    mAppThread.scheduleSendResult(token, list);                                                    ---&gt;
}

 public final void scheduleSendResult(IBinder token, List&lt;ResultInfo&gt; results) {
        ResultData res = new ResultData();
        res.token = token;
        res.results = results;
        sendMessage(H.SEND_RESULT, res);                                                        ---&gt;
    }

 public void handleMessage(Message msg) {
    ......
      case SEND_RESULT:
                Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;activityDeliverResult&quot;);
                handleSendResult((ResultData)msg.obj);                                            ---&gt;s
                Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);
                break;
    }

private void handleSendResult(ResultData res) {
    ......
     deliverResults(r, res.results);                                                                 ---&gt;
}

private void deliverResults(ActivityClientRecord r, List&lt;ResultInfo&gt; results) {
    final int N = results.size();
    for (int i=0; i&lt;N; i++) {
        ResultInfo ri = results.get(i);
        try {
            if (ri.mData != null) {
                ri.mData.setExtrasClassLoader(r.activity.getClassLoader());
                ri.mData.prepareToEnterProcess();
            }
            if (DEBUG_RESULTS) Slog.v(TAG,
                    &quot;Delivering result to activity &quot; + r + &quot; : &quot; + ri);
            r.activity.dispatchActivityResult(ri.mResultWho,                                    ---&gt;
                    ri.mRequestCode, ri.mResultCode, ri.mData);
        } catch (Exception e) {
            if (!mInstrumentation.onException(r.activity, e)) {
                throw new RuntimeException(
                        &quot;Failure delivering result &quot; + ri + &quot; to activity &quot;
                        + r.intent.getComponent().toShortString()
                        + &quot;: &quot; + e.toString(), e);
            }
        }
    }
}
</code></pre><p>—-&gt;Activity.java——&gt;dispatchActivityResult()方法</p>
<pre><code>void dispatchActivityResult(String who, int requestCode,
    int resultCode, Intent data) {
    if (false) Log.v(
        TAG, &quot;Dispatching result: who=&quot; + who + &quot;, reqCode=&quot; + requestCode
        + &quot;, resCode=&quot; + resultCode + &quot;, data=&quot; + data);
    mFragments.noteStateNotSaved();
    if (who == null) {
        onActivityResult(requestCode, resultCode, data);-------------&gt;关键点Activity中onActivityResult回调
    } else if (who.startsWith(REQUEST_PERMISSIONS_WHO_PREFIX)) {
        who = who.substring(REQUEST_PERMISSIONS_WHO_PREFIX.length());
        if (TextUtils.isEmpty(who)) {
            dispatchRequestPermissionsResult(requestCode, data);
        } else {
            Fragment frag = mFragments.findFragmentByWho(who);
            if (frag != null) {
                dispatchRequestPermissionsResultToFragment(requestCode, data, frag);
            }
        }
    } else if (who.startsWith(&quot;@android:view:&quot;)) {
        ArrayList&lt;ViewRootImpl&gt; views = WindowManagerGlobal.getInstance().getRootViews(
                getActivityToken());
        for (ViewRootImpl viewRoot : views) {
            if (viewRoot.getView() != null
                    &amp;&amp; viewRoot.getView().dispatchActivityResult(
                            who, requestCode, resultCode, data)) {
                return;
            }
        }
    } else if (who.startsWith(AUTO_FILL_AUTH_WHO_PREFIX)) {
        Intent resultData = (resultCode == Activity.RESULT_OK) ? data : null;
        getAutofillManager().onAuthenticationResult(requestCode, resultData);
    } else {
        Fragment frag = mFragments.findFragmentByWho(who);-------------&gt;关键点Fragment中onActivityResult回调
        if (frag != null) {
            frag.onActivityResult(requestCode, resultCode, data);
        }
    }
}
</code></pre><p><strong>所以不管是Fragment还是Activity，调用startActivityForResult()方法都会走：</strong></p>
<pre><code>if (who == null) {
        onActivityResult(requestCode, resultCode, data);-------------&gt;关键点Activity中onActivityResult回调
}
</code></pre><p><strong>所以正常情况下是都可以拿到回调的，而我这里出现问题，只能说明是我代码哪里出了问题，仔细查询一番才发现，原来，没有处理嵌套Fragment的情况，也就是说回调只到第一级Fragment，就没有继续分发。我们可以实现一个自己的FragmentActiviy，来实现继续分发：</strong></p>
<pre><code> @Override
protected void onActivityResult(int requestCode, int resultCode, Intent data) {
    super.onActivityResult(requestCode, resultCode, data);
    android.support.v4.app.FragmentManager supportFragmentManager = getSupportFragmentManager();
    if (null != supportFragmentManager) {
        Fragment fragment = supportFragmentManager.findFragmentByTag(FOUND);
        if (null != fragment) fragment.onActivityResult(requestCode, resultCode, data);
    }
}
</code></pre><p><strong>另外注意：如果重写了activity的onActivityResult()方法， 而没有super.onActivityResult(),那么在fragment中onActivityResult()就不会被调用，因为super.onActivityResult()会去找当前activity的fragment进行回调分发</strong></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/标签-日常踩坑/">标签:日常踩坑</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Glide学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/09/13/Glide学习/" class="article-date">
  	<time datetime="2018-09-13T08:11:36.499Z" itemprop="datePublished">2018-09-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##Glide学习</p>
<p>####首先Glide用法很简单，举个最简单的例子:</p>
<pre><code>Glide.with(ctx).load(url).into(imageView);
</code></pre><p>就这一句很简单的链式调用就完成了我们本该做的复杂的异步请求回调，Glide到底是如何做到的？</p>
<p><strong>先来看看 with()方法：</strong></p>
<pre><code>竟然有五个with()重载方法-------------&gt;

public static RequestManager with(Context context) {
    RequestManagerRetriever retriever = RequestManagerRetriever.get();
    return retriever.get(context);
}

public static RequestManager with(Activity activity) {
    RequestManagerRetriever retriever = RequestManagerRetriever.get();
    return retriever.get(activity);
}

public static RequestManager with(FragmentActivity activity) {
    RequestManagerRetriever retriever = RequestManagerRetriever.get();
    return retriever.get(activity);
}

@TargetApi(Build.VERSION_CODES.HONEYCOMB)
public static RequestManager with(android.app.Fragment fragment) {
    RequestManagerRetriever retriever = RequestManagerRetriever.get();
    return retriever.get(fragment);
}

  public static RequestManager with(Fragment fragment) {
    RequestManagerRetriever retriever = RequestManagerRetriever.get();
    return retriever.get(fragment);
}
</code></pre><p><strong>这几个重载最终目的都是为了拿到一个 RequestManager 对象，这个对象是什么？ 有什么作用？</strong></p>
<pre><code>public class RequestManager implements LifecycleListener {
    ......
}
</code></pre><p>注释是这么说的：</p>
<p><strong>用于管理和启动Glide请求的类。可以使用活动、片段和连接生命周期事件来智能地停止、启动和重新启动请求。通过实例化一个新对象来检索，或者利用活动和片段生命周期处理中内置的优势，使用静态滑翔。使用片段或活动加载方法。</strong></p>
<p><strong>而且Glide中运用了一个小技巧，通过创建一个没有视图的 Fragment 来持有创建好的RequestManager对象</strong></p>
<p>这个了类有800多行代码，一时半会儿看不完，先直接跳到&nbsp;&nbsp; <strong>RequestManager的load()方法</strong>&nbsp;&nbsp;分析一波–&gt;</p>
<pre><code>public DrawableTypeRequest&lt;String&gt; load(String string) {
    return (DrawableTypeRequest&lt;String&gt;) fromString().load(string);
}

public DrawableTypeRequest&lt;String&gt; fromString() {
    return loadGeneric(String.class);
}

public DrawableTypeRequest&lt;Uri&gt; load(Uri uri) {
    return (DrawableTypeRequest&lt;Uri&gt;) fromUri().load(uri);
}

@Deprecated
public DrawableTypeRequest&lt;URL&gt; fromUrl() {
    return loadGeneric(URL.class);
}

private &lt;T&gt; DrawableTypeRequest&lt;T&gt; loadGeneric(Class&lt;T&gt; modelClass) {
    ModelLoader&lt;T, InputStream&gt; streamModelLoader = Glide.buildStreamModelLoader(modelClass, context);
    ModelLoader&lt;T, ParcelFileDescriptor&gt; fileDescriptorModelLoader =
            Glide.buildFileDescriptorModelLoader(modelClass, context);
    if (modelClass != null &amp;&amp; streamModelLoader == null &amp;&amp; fileDescriptorModelLoader == null) {
        throw new IllegalArgumentException(&quot;Unknown type &quot; + modelClass + &quot;. You must provide a Model of a type for&quot;
                + &quot; which there is a registered ModelLoader, if you are using a custom model, you must first call&quot;
                + &quot; Glide#register with a ModelLoaderFactory for your custom model class&quot;);
    }

    return optionsApplier.apply(
            new DrawableTypeRequest&lt;T&gt;(modelClass, streamModelLoader, fileDescriptorModelLoader, context,
                    glide, requestTracker, lifecycle, optionsApplier));
}s
</code></pre><p>可以看到<strong>load()方法终究会通过一个laodGeneric(Class<t> modelClass)方法生成一个DrawableTypeRequest<t>对象</t></t></strong></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-Semaphore学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/17/Semaphore学习/" class="article-date">
  	<time datetime="2018-05-17T09:37:36.000Z" itemprop="datePublished">2018-05-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/17/Semaphore学习/">
        Semaphore 类的学习使用
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##semaphore</p>
<p><strong>1.semaphore是什么？</strong></p>
<p>信号量（semaphore）,有时被称为信号灯，是在多线程环境下使用的一种设施，它负责协调各个线程，以保证他们能够合理的使用公共资源。</p>
<p>semaphore分为单值和多值两种，前者只能被一个线程获得，后者可以被多个线程获得。</p>
<p>单个信号量的Semaphore对象可以实现互斥锁的功能，并且可以是由一个线程获得了“锁”，再由另一个线程释放“锁”，这可应用于死锁恢复的一些场合。</p>
<p><strong>2.主要方法</strong></p>
<pre><code>Semaphore semaphore = new Semaphore(int count);
</code></pre><p>信号量Semaphore的初始化方法，初始值 count 表示当前的信号量，即当前所允许并发访问的线程数。</p>
<pre><code>semaphore.acquire();
</code></pre><p>表示获得一个许可，若信号量中的许可数已为0，则这个函数会出现等待的状况； 若已获取许可，则这个信号量的许可数为减一；</p>
<pre><code>semaphore.release();
</code></pre><p>表示释放一个许可，若之前信号量的许可数已为0，那么当调用semaphore.release() 函数时，则此时的信号量中的许可数就会变为1；简而言之，就是将这个信号量中的许可数在原来的基础上 增加一个，而无论信号量之前的初始值是什么；</p>
<pre><code>semaphore.availablePermits();
</code></pre><p>表示信号量semaphore此刻所拥有的许可数的个数</p>
<p><strong>3.实例</strong></p>
<p>现在有一个三个信号灯，启动10个线程分别获取信号灯，当信号灯被占用时，其他线程只能等待，当信号灯被释放则等待线程获取信号灯。</p>
<pre><code>   public class SemaphoreTest {
     public static void main(String[] args) {
         ExecutorService pool =  Executors.newCachedThreadPool();
         final Semaphore semaphore = new Semaphore(3,true);

         for (int i = 0; i &lt; 10; i++) {
             Runnable runnable = new Runnable() {
                 @Override
                 public void run() {
                    try {
                        semaphore.acquire();//获取信号灯许可
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                    System.out.println(&quot;Thread &quot;+Thread.currentThread().getName()+&quot; 进入&quot; +&quot;当前系统的并发数是：&quot;+(3-semaphore.availablePermits()));
                    try {
                        Thread.sleep(new Random().nextInt(1000));
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                    System.out.println(&quot;Thread &quot;+Thread.currentThread().getName()+&quot; 即将离开&quot;);
                    semaphore.release();//释放信号灯
                    System.out.println(&quot;Thread &quot;+Thread.currentThread().getName()+&quot; 已经离开，当前系统的并发数是：&quot;+(3-semaphore.availablePermits()));
                }
            };
            pool.execute(runnable);

        }
    }
}
</code></pre><p>另外需要注意的一点是，信号灯可以由一个线程使用，然后由另一个线程来进行释放，而锁只能由同一个线程启动和释放，不然就好发生死锁，这一点需要格外注意。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/标签：多线程/">标签：多线程</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-高德地图加载瓦片分析" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/05/17/高德地图加载瓦片分析/" class="article-date">
  	<time datetime="2018-05-17T09:37:36.000Z" itemprop="datePublished">2018-05-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/05/17/高德地图加载瓦片分析/">
        高德地图加载瓦片分析
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>##了解瓦片地图<br><strong><code>瓦片地图</code></strong>：瓦片地图金字塔模型是一种多分辨率层次模型，从瓦片金字塔的底层到顶层，分辨率越来越低，但表示的地理范围不变。首先确定地图服务平台所要提供的缩放级别的数量N，把缩放级别最高、地图比例尺最大的地图图片作为金字塔的底层，即第0层，并对其进行分块，从地图图片的左上角开始，从左至右、从上到下进行切割，分割成相同大小(比如256x256像素)的正方形地图瓦片，形成第0层瓦片矩阵;在第0层地图图片的基础上，按每2x2像素合成为一个像素的方法生成第1层地图图片，并对其进行分块，分割成与下一层相同大小的正方形地图瓦片，形成第1层瓦片矩阵;采用同样的方法生成第2层瓦片矩阵;…;如此下去，直到第N一1层，构成整个瓦片金字塔———————— <code>来自百度百科</code></p>
<p>首先，我们先分析一下高德地图，高德有2D和3D两种地图,2D地图栅栏地图（属于瓦片地图），采用切的方式显示地图，而3D地图为矢量地图，采用终端绘制地图的样式，地图功能更丰富一些。所以用高德地图要想成功的加载出来自定义的瓦片，一定要用高德里面提供的 <strong>2D地图</strong>的SDK 否则没有任何效果。</p>
<p><img src="https://github.com/silenceyixia/silenceyixia.github.io/raw/master/pics/gaode_titl_detail.jpg" alt="avatar"></p>
<p>现在地图相关业务的需求已很是常见，但有时候不免会有一些定制、个性化的需求，比如地图加载自定义瓦片就是这样的一个需求，今天就高德地图加载瓦片进行一番分析：</p>
<p>##分析</p>
<p>###1.集成高德地图<br>申请key等等的流程就不叙述了</p>
<p>implementation ‘com.amap.api:map2d:5.0.1’</p>
<p><strong>布局文件：</strong></p>
<pre><code>&lt;FrameLayout
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    &gt;

       &lt;com.amap.api.maps2d.MapView
           android:id=&quot;@+id/map_view&quot;
           android:layout_width=&quot;match_parent&quot;
           android:layout_height=&quot;match_parent&quot;
      /&gt;

&lt;/FrameLayout&gt;
</code></pre><p><strong>MainActivity</strong>就不多说了：</p>
<pre><code>import android.app.Activity;
import android.os.Environment;
import android.support.v7.app.AppCompatActivity;
import android.os.Bundle;
import android.view.View;
import android.widget.Button;

import com.amap.api.maps2d.AMap;
import com.amap.api.maps2d.MapView;
import com.amap.api.maps2d.model.TileOverlay;
import com.amap.api.maps2d.model.TileOverlayOptions;
import com.amap.api.maps2d.model.UrlTileProvider;

import java.net.URL;

public class MainActivity extends Activity{
    private MapView mMapView;
    private AMap aMap;
    private TileOverlay mtileOverlay;

@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    setContentView(R.layout.activity_main);
    mMapView = (MapView) findViewById(R.id.map_view);
    mMapView.onCreate(savedInstanceState);//必须的
    if (aMap == null) {
        aMap = mMapView.getMap();
    }
     //移动中心点到故宫
    aMap.moveCamera(CameraUpdateFactory.newLatLngZoom(new LatLng(39.918255, 116.397369), 15));
}

@Override
protected void onResume() {
    super.onResume();
    //在activity执行onResume时执行mMapView.onResume ()，重新绘制加载地图
    mMapView.onResume();
    //我们可以在这里进行离线瓦片的加载(在线瓦片和离线瓦片一样只不过一个是本地瓦片存储路径，一个是网络Url)
    loadOffLineMap();
}

@Override
protected void onPause() {
    super.onPause();
    //在activity执行onPause时执行mMapView.onPause ()，暂停地图的绘制
    mMapView.onPause();
}

@Override
protected void onSaveInstanceState(Bundle outState) {
    super.onSaveInstanceState(outState);
    mMapView.onSaveInstanceState(outState);//保存地图当前的状态
}

@Override
protected void onDestroy() {
    super.onDestroy();
    //在activity执行onDestroy时执行mMapView.onDestroy()，销毁地图
    mMapView.onDestroy();
}

/**
 * 加载离线线瓦片数据
 */
private void loadOffLineMap() {
    final String url = &quot;/storage/emulated/0/amap/tilecache&quot;;
    TileOverlayOptions tileOverlayOptions = 
    new TileOverlayOptions().tileProvider(new LocalTileProvider(url));
    tileOverlayOptions.diskCacheEnabled(true)
            .diskCacheDir(&quot;/storage/emulated/0/amap/OMCcache&quot;)
            .diskCacheSize(100000)
            .memoryCacheEnabled(true)
            .memCacheSize(100000)
            .zIndex(-9999);
    mtileOverlay = aMap.addTileOverlay(tileOverlayOptions);
}

//实现TitlProvider 用于加载本瓦片
class LocalTileProvider implements  TileProvider{

    private static final int TILE_WIDTH = 256;
    private static final int TILE_HEIGHT = 256;
    public static final int BUFFER_SIZE = 16 * 1024;
    private String tilePath;

    public LocalTileProvider(String path) {
        tilePath=path;
    }

    @Override
    public Tile getTile(int x, int y, int zoom) {
        byte[] image = readTileImage(x, y, zoom);
        return image == null ? null : new Tile(TILE_WIDTH, TILE_HEIGHT, image);
    }

       private byte[] readTileImage(int x, int y, int zoom) {
        InputStream in = null;
        ByteArrayOutputStream buffer = null;
        File f = new File(getTileFilename(x, y, zoom));
        if(f.exists()){
            try {
                buffer = new ByteArrayOutputStream();
                in = new FileInputStream(f);
                int nRead;
                byte[] data = new byte[BUFFER_SIZE];
                while ((nRead = in.read(data, 0, BUFFER_SIZE)) != -1) {
                buffer.write(data, 0, nRead);
                }
                buffer.flush();
                return buffer.toByteArray();
               } catch (IOException e) {
                e.printStackTrace();
                return null;
               } catch (OutOfMemoryError e) {
                e.printStackTrace();
                return null;
            } finally {
                    if (in != null)
                    try {
                        in.close(); 
                     } catch (Exception e) {
                      }
                 if (buffer != null)
                    try {
                        buffer.close(); 
                    } catch (Exception e) {
                    }
                  }
        }else{
            return null;
           }
       }

    private String getTileFilename(int x, int y, int zoom) {
          //这里一定要注意，由于瓦片都是由专门的切图工具生成，这个x,y指的是切片工具根据该瓦片在地图上中心点经纬度的
            所生成的固定的值，所以瓦片图片的名字千万不要随意改动，而这个z值则是当前地图缩放级别，当你缩放地图时高德
            地图就会不停的监控地图级别然后在指定的本地路径查找对应的瓦片进行加载
            return tilePath + &quot;/&quot; + x + &quot;_&quot; + y + &quot;_&quot; + zoom + &quot;.png&quot;;
    }

    @Override
    public int getTileWidth() {
        return TILE_HEIGHT;
    }

    @Override
    public int getTileHeight() {
        return TILE_WIDTH;
    }
  }
}
</code></pre><p><strong>且看效果图:</strong></p>
<p><img src="https://github.com/silenceyixia/silenceyixia.github.io/raw/master/pics/gaode_titl_shot.png" alt="avatar"></p>
<p>##项目源码<br><a href="https://github.com/silenceyixia/KotlinTestDaily" title="高德地图加载本地瓦片项目源码" target="_blank" rel="external">kotlin版</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/标签：高德地图/">标签：高德地图</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-AsyncTask 源码学习" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2018/03/05/AsyncTask 源码学习/" class="article-date">
  	<time datetime="2018-03-04T16:00:00.000Z" itemprop="datePublished">2018-03-05</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/03/05/AsyncTask 源码学习/">
        AsyncTask源码学习
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>由于android中UI线程（主进程）是线程不安全的，如果想要在子线程进行更新UI操作，就需要借助android的异步消息处理机制，在android中实<br>现异步处理机制有两种方式：Handler和AsyncTask.这两种方式平时也经常用到。最近我心血来潮就想了解一下AsyncTask内部源码到底是如何实现的?毕竟知其然且知其所以然会对让自己对AsyncTask的了解更近一步，同时也可以学习一下AsyncTask设计的思路。</p>
<h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="注：这是基于android-25的AsyncTask源码解析。"><a href="#注：这是基于android-25的AsyncTask源码解析。" class="headerlink" title="注：这是基于android-25的AsyncTask源码解析。"></a>注：这是基于android-25的AsyncTask源码解析。</h3><h6 id="首先打开AsyncTask-java文件找到定义："><a href="#首先打开AsyncTask-java文件找到定义：" class="headerlink" title="首先打开AsyncTask.java文件找到定义："></a>首先打开<strong>AsyncTask.java</strong>文件找到定义：</h6><pre><code>  public abstract class AsyncTask&lt;Params, Progress, Result&gt; {
      ......
}
</code></pre><p>可以看到AsyncTask是一个<strong>抽象类</strong>，所以使用它就需要继承并实现其抽象方法 <strong>doInbackground()</strong> 方法；</p>
<h6 id="使用过-AsyncTask-异步的都知道，任务执行的入口是-excute-方法："><a href="#使用过-AsyncTask-异步的都知道，任务执行的入口是-excute-方法：" class="headerlink" title="使用过 AsyncTask 异步的都知道，任务执行的入口是 excute() 方法："></a>使用过 <strong>AsyncTask</strong> 异步的都知道，任务执行的入口是 <strong>excute()</strong> 方法：</h6><pre><code>//方法１
 public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) {
    return executeOnExecutor(sDefaultExecutor, params);
}    

//方法２
public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec,Params... params) {

    if (mStatus != Status.PENDING) {
        switch (mStatus) {
            case RUNNING:
                throw new IllegalStateException(&quot;Cannot execute task:&quot;
                        + &quot; the task is already running.&quot;);
            case FINISHED:
                throw new IllegalStateException(&quot;Cannot execute task:&quot;
                        + &quot; the task has already been executed &quot;
                        + &quot;(a task can be executed only once)&quot;);
        }
    }

    mStatus = Status.RUNNING;

    onPreExecute();

    mWorker.mParams = params;
    exec.execute(mFuture);

    return this;
   }
</code></pre><p>根据上面的代码，可以发现只需研究 <strong>executeOnExecutor()</strong> 方法就行。分析如下：</p>
<hr>
<h5 id="首先对-mStatus-进行了判断，mStatus-初始化："><a href="#首先对-mStatus-进行了判断，mStatus-初始化：" class="headerlink" title="首先对 mStatus 进行了判断，mStatus 初始化："></a>首先对 <strong>mStatus</strong> 进行了判断，<strong>mStatus</strong> 初始化：</h5><pre><code>private volatile Status mStatus = Status.PENDING
</code></pre><p>PENDING 指示任务尚未执行， </p>
<h5 id="接着执行："><a href="#接着执行：" class="headerlink" title="接着执行："></a>接着执行：</h5><pre><code>mStatus = Status.RUNNING;
</code></pre><p>将 <strong>mStatus</strong> 置为 <strong>RUNNING</strong> </p>
<h5 id="然后调用了-onPreExecute-方法，子类通过重写该方法用于异步任务执行前进行一些预备工作"><a href="#然后调用了-onPreExecute-方法，子类通过重写该方法用于异步任务执行前进行一些预备工作" class="headerlink" title="然后调用了 onPreExecute() 方法，子类通过重写该方法用于异步任务执行前进行一些预备工作"></a>然后调用了 <strong>onPreExecute()</strong> 方法，子类通过重写该方法用于异步任务执行前进行一些预备工作</h5><h5 id="接下来可以看到-mWorker-mParams-的赋值，那么-mWorker-是什么？什么时候初始化的？"><a href="#接下来可以看到-mWorker-mParams-的赋值，那么-mWorker-是什么？什么时候初始化的？" class="headerlink" title="接下来可以看到 mWorker.mParams 的赋值，那么 mWorker 是什么？什么时候初始化的？"></a>接下来可以看到 <strong>mWorker.mParams</strong> 的赋值，那么 <strong>mWorker</strong> 是什么？什么时候初始化的？</h5><pre><code>private final WorkerRunnable&lt;Params, Result&gt; mWorker;

private static abstract class WorkerRunnable&lt;Params, Result&gt; implements Callable&lt;Result&gt; {
       Params[] mParams;
}

public interface Callable&lt;V&gt; {
    V call() throws Exception;
}
</code></pre><p>可以看到 <strong>WorkerRunnable抽象类</strong>，原来 <strong>executeOnExecutor(Executor exec,Params… params)</strong> 方法传入的 <strong>Params</strong> 可变参数是赋给了 <strong>WorkerRunnable</strong> 类的唯一的字段 <strong>mParams</strong> ，<strong>WorkerRunnable</strong> 是 <strong>Callable接口</strong> 的子类，查阅资料后发现其实 <strong>Callable</strong> 和 <strong>Runnable</strong> 是一样的作用，不过 <strong>Callable</strong> 的 <strong>call()</strong> 方法是有返回值的，而且可以抛异常，那么 <strong>WorkerRunnable</strong> 实现 <strong>Callable</strong> 的意义在何在？接着看源码找到了 <strong>mWorker</strong> 的初始化—&gt; 在 <strong>AsyncTask</strong> 的构造方法中：</p>
<pre><code>public AsyncTask() {
    mWorker = new WorkerRunnable&lt;Params, Result&gt;() {
        public Result call() throws Exception {
        mTaskInvoked.set(true);
        Result result = null;
        try {
           Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
           //noinspection unchecked
           result = doInBackground(mParams);
           Binder.flushPendingCommands();
        } catch (Throwable tr) {
           mCancelled.set(true);
           throw tr;
        } finally {
           postResult(result);
        }
           return result;
        }
   };

  mFuture = new FutureTask&lt;Result&gt;(mWorker) {
      @Override
      protected void done() {
         try {
            postResultIfNotInvoked(get());
         } catch (InterruptedException e) {
            android.util.Log.w(LOG_TAG, e);
         } catch (ExecutionException e) {
            throw new RuntimeException(&quot;An error occurred while executing doInBackground()&quot;,e.getCause());
         } catch (CancellationException e) {
            postResultIfNotInvoked(null);
         }
      }
   };
}
</code></pre><p>不仅看到了 <strong>WorkerRunnable</strong> 的实例化，还有一个 <strong>FutureTask</strong> 的实例化，而且 <strong>WorkerRunnable</strong> 是 作为参数传入了 <strong>FutureTask</strong> 的构造函数中，接下来看看 <strong>FutureTask</strong> 又是什么样的存在？</p>
<pre><code>public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; {
    //......
    public FutureTask(Callable&lt;V&gt; callable) {
         if (callable == null)
            throw new NullPointerException();
         this.callable = callable;
         this.state = NEW;       // ensure visibility of callable
    }
    ......
}

public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; {        
    void run();    
}

interface Runnable {
    public abstract void run();
}

public interface Future&lt;V&gt; {

    boolean cancel(boolean mayInterruptIfRunning);

    boolean isCancelled();

    boolean isDone();

    V get() throws InterruptedException, ExecutionException;

    V get(long timeout, TimeUnit unit)throws InterruptedException, ExecutionException, TimeoutException;
}
</code></pre><p>现在知道 <strong>mWorker(WorkerRunnable)</strong> 是 <strong>mFuture(FutureTask)</strong> 中的一个成员，而且 <strong>FutureTask</strong> 实现了<br><strong>RunnableFuture</strong><br>    <strong>Runnable</strong>，<strong>Future</strong> 三个接口，<strong>RunnableFuture接口</strong> 的作用就是将其他两个接口整合到一起。<strong>Future</strong> 接口是用来干嘛的？ 留到后面分析。</p>
<h5 id="最后来看最重要的一步："><a href="#最后来看最重要的一步：" class="headerlink" title="最后来看最重要的一步："></a>最后来看最重要的一步：</h5><pre><code>exec.execute(mFuture);
</code></pre><p><strong>exec</strong> 是什么，从哪里来的？正是最初执行 <strong>execute(Params… params)</strong> –&gt;<strong>executeOnExecutor(Executor exec,Params… params)</strong> 从参数传进来的,来看看具体是怎么回事：</p>
<pre><code>public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) {
    return executeOnExecutor(sDefaultExecutor, params);
}

private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR;

private static class SerialExecutor implements Executor {

       final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;();
       Runnable mActive;

    public synchronized void execute(final Runnable r) {
         mTasks.offer(new Runnable() {
            public void run() {
              try {
                r.run();
              } finally {
                scheduleNext();
              }
            }
         });

         if (mActive == null) {
            scheduleNext();
         }
    }

   protected synchronized void scheduleNext() {
         if ((mActive = mTasks.poll()) != null) {
            THREAD_POOL_EXECUTOR.execute(mActive);
         }
   }
}

public interface Executor {    
    void execute(Runnable command);
}
</code></pre><p>这块可以看到由 <strong>mTasks(ArrayDeque)</strong> 将 <strong>r(Runnable)</strong> 加入了 <strong>mTask</strong> 的队尾，其实 <strong>r</strong> 就是前面说到的<strong>mFuture(FutureTask)</strong>,<br><strong>ArrayDeque</strong>是java里面一种数据结构(双端队列)的实现类，能够无限扩展队列大小，具体我也没有过多研究，有空再了解一下 <strong>ArrayDeque</strong> 源码。</p>
<p>辗转反侧来到了 </p>
<pre><code>THREAD_POOL_EXECUTOR.execute(mActive);
</code></pre><p>由 <strong>线程池THREAD_POOL_EXECUTOR</strong> 来执行了 <strong>mActive</strong>, 这个 <strong>mActive</strong> 也就是从 <strong>mTask</strong> 中取出来的 <strong>mFuture</strong> ,因为 <strong>FutureTask</strong> 是 <strong>Runnabe</strong> 的子类，那也就是说会调用 <strong>FutureTask</strong> 类的 <strong>run()</strong><br>方法，也就是说<strong>从这里开始就是在子线程开始执行任务</strong>了，找到 <strong>run()</strong> 方法源码：</p>
<pre><code>public void run() {
     if (state != NEW ||!U.compareAndSwapObject(this, RUNNER, null, Thread.currentThread()))
        return;
     try {
        Callable&lt;V&gt; c = callable;
           if (c != null &amp;&amp; state == NEW) {
              V result;
              boolean ran;
              try {
                 result = c.call();
                 ran = true;
              } catch (Throwable ex) {
                 result = null;
                 ran = false;
                 setException(ex);
              }
              if (ran)
                 set(result);
              }
      } finally {
      ......
    }
}
</code></pre><p>找到了核心代码：</p>
<pre><code>result = c.call();
</code></pre><p>可以看到调用 <strong>c</strong> 的 <strong>call()</strong> 方法，这个 <strong>c</strong> 就是 初始化 <strong>mFuture(FutureTask)</strong> 的时候传进来的 <strong>mWorker(WorkerRunnable)</strong> ，回去找 <strong>mWorker</strong> 去：</p>
<pre><code>mWorker = new WorkerRunnable&lt;Params, Result&gt;() {
    public Result call() throws Exception {
         mTaskInvoked.set(true);
         Result result = null;
         try {
               Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
            //noinspection unchecked
            result = doInBackground(mParams);
            Binder.flushPendingCommands();
         } catch (Throwable tr) {
            mCancelled.set(true);
            throw tr;
         } finally {
            postResult(result);
         }
            return result;
    }
};
</code></pre><p>哈哈，终于知道了 <strong>doInBackground()</strong>方法的调用时机，<strong>result</strong> 就是 <strong>doInBackground()</strong> 方法执行完返回的结果，接着看到 <strong>finally</strong>代码块里面的 <strong>postResult()</strong> 方法：</p>
<pre><code>postResult(result);

private Result postResult(Result result) {
    @SuppressWarnings(&quot;unchecked&quot;)
    Message message = getHandler().obtainMessage(MESSAGE_POST_RESULT,
             new AsyncTaskResult&lt;Result&gt;(this, result));
    message.sendToTarget();
    return result;
} 

private static Handler getHandler() {
    synchronized (AsyncTask.class) {
       if (sHandler == null) {
          sHandler = new InternalHandler();
       }
       return sHandler;
    }
 }

private static class InternalHandler extends Handler {
     public InternalHandler() {
        super(Looper.getMainLooper());
     }

     @SuppressWarnings({&quot;unchecked&quot;, &quot;RawUseOfParameterizedType&quot;})
        @Override
        public void handleMessage(Message msg) {
        AsyncTaskResult&lt;?&gt; result = (AsyncTaskResult&lt;?&gt;) msg.obj;
            switch (msg.what) {
                case MESSAGE_POST_RESULT:
                    // There is only one result
                    result.mTask.finish(result.mData[0]);
                    break;
                case MESSAGE_POST_PROGRESS:
                        result.mTask.onProgressUpdate(result.mData);
                    break;
            }
       }
}

private void finish(Result result) {
   if (isCancelled()) {
      onCancelled(result);
   } else {
      onPostExecute(result);
   }
   mStatus = Status.FINISHED;
}
</code></pre><p>到现在终于真相大白了，直接看 <strong>InternalHandler</strong> 的初始化–&gt; <strong>Looper.getMainLooper()</strong>,用的就是 <strong>主线程(UI线程)的Handler</strong>，接着看结果回调—&gt; <strong>result.mTask.finish(result.mData[0]);</strong> 最后–&gt; <strong>onPostExecute(result);</strong> </p>
<hr>
<p>到这里整个AsyncTask异步任务也就全部完成了。这仅是我在 学习 AsyncTask源码后的个人分析。 </p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/标签-源码分析/">标签:源码分析</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-设计模式总结" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/12/21/设计模式总结/" class="article-date">
  	<time datetime="2017-12-21T08:24:14.000Z" itemprop="datePublished">2017-12-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/12/21/设计模式总结/">
        设计模式总结
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h6 id="前面学习了一部分创建型模式，发现了一个比设计模式更重要的东西：设计模式原则。对于设计模式来说，为什么这个模式要这样解决这个问题，而另一个模式要那样，它们背后都遵循的就是永恒的设计原则。可以说，设计原则是设计模式的灵魂。"><a href="#前面学习了一部分创建型模式，发现了一个比设计模式更重要的东西：设计模式原则。对于设计模式来说，为什么这个模式要这样解决这个问题，而另一个模式要那样，它们背后都遵循的就是永恒的设计原则。可以说，设计原则是设计模式的灵魂。" class="headerlink" title="前面学习了一部分创建型模式，发现了一个比设计模式更重要的东西：设计模式原则。对于设计模式来说，为什么这个模式要这样解决这个问题，而另一个模式要那样，它们背后都遵循的就是永恒的设计原则。可以说，设计原则是设计模式的灵魂。"></a>前面学习了一部分创建型模式，发现了一个比设计模式更重要的东西：设计模式原则。对于设计模式来说，为什么这个模式要这样解决这个问题，而另一个模式要那样，它们背后都遵循的就是永恒的设计原则。可以说，设计原则是设计模式的灵魂。</h6><h5 id="三大基本面向对象设计原则-1-针对接口编程，而不是针对实现编程-；2。优先使用对象组全，而不是类继承；3-封装变化点。"><a href="#三大基本面向对象设计原则-1-针对接口编程，而不是针对实现编程-；2。优先使用对象组全，而不是类继承；3-封装变化点。" class="headerlink" title="三大基本面向对象设计原则:1.针对接口编程，而不是针对实现编程 ；2。优先使用对象组全，而不是类继承；3.封装变化点。"></a>三大基本面向对象设计原则:1.针对接口编程，而不是针对实现编程 ；2。优先使用对象组全，而不是类继承；3.封装变化点。</h5><h3 id="1-单一职责原则（SRP）"><a href="#1-单一职责原则（SRP）" class="headerlink" title="1.单一职责原则（SRP）"></a>1.单一职责原则（SRP）</h3><p>单一职责原则（SRP），就一个类而言，应该仅有一个引起它变化的原因。也就是说，不要把变化原因各不相同的职责放在一起，因为不同的变化会影响到不相干的职责。再通俗一点地说就是，不该你管的事情你不要管，管好自己的事情就可以了，多管闲事害了自己也害了别人。<br>在软件设计中，如果一个类承担的职责过多，就等于吧这些职责耦合在一起，而一个职责的变化可能会削弱和抑制这个类完成其他职责的能力。这耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。<br>软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。如果多于一个的动机去改变一个类，那么这个类就具有多余一个的职责，就应该要考虑类的职责分离。</p>
<h3 id="2-开放-封闭原则（The-Open-Closed-Principle-简称OCP）"><a href="#2-开放-封闭原则（The-Open-Closed-Principle-简称OCP）" class="headerlink" title="2.开放-封闭原则（The Open-Closed Principle 简称OCP）"></a>2.开放-封闭原则（The Open-Closed Principle 简称OCP）</h3><p>开放-封闭原则，或叫开-闭原则，是说软件实体(类、模块、函数等)应该是可以扩展的，但是不可修改。不修改的意思就是是“你可以随便增加新的类，但是不要修改原来的类”。从这个角度去理解就好多了，其实这里还是一个隔离变化的问题。<br>这个原则的两个特征：一个是对于扩展是开放的；另一个是对于更改是封闭的。<br>我们在设计开发任何系统时，都不可能指望系统一开始就需求确定，就不再变化（要这样就太幸福了，哈哈），这是不现实的也是不科学的想法。既然需求是有一定变化的，那么如何在面对需求变化时，设计的程序可以相对容易的修改，不至于说，新需求一来，就要把整个程序推倒重来(这样会让程序员疯了不可，哈哈，你不想疯吧)。怎样的设计才能面对需求的改变却可以保持相对稳定，从而使得系统可以在第一个版本以后不断推出的新版本呢？开放-封闭原则就是我们的答案。<br>在程序设计时，我们要时刻考虑尽量把类设计的足够好，写好了就不要去修改，如果有新的需求来了，我们增加一些类来完成新的需求，原来的代码能不动就不动。<br>绝对的对修改关闭是不可能的，无论模块是多么的封闭，都会存在一些无法对之封闭的变化，既然不能完全封闭，设计人员必须对他设计的模块应该对那种变化封闭做出抉择、他必须事先猜测出最有可能发生变化的变化种类，然后构建抽象来隔离那些变化。<br>开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所生成的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的部分都做出抽象，然后，对于应用程序中的每部分都刻意定进行抽象同样不是一个好主意，拒绝不成熟的抽象和抽象本身一样重要。</p>
<h3 id="3-依赖倒转原则"><a href="#3-依赖倒转原则" class="headerlink" title="3.依赖倒转原则"></a>3.依赖倒转原则</h3><p>依赖倒转原则：抽象不应该依赖于细节。细节应该依赖于抽象；高层不应该依赖于底层，两者都应该依赖于抽象。说白了就是要针对接口编程，不要针对实现编程。抽象的东西才是最稳定的，也就是说，我们依赖的是它的稳定。<br>依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写是考虑的都是如何针对抽象编程而不是针对细节编程，即程序中的所有的依赖关系都是终止与抽象类或者接口，那就是面向对象的设计，反之就是过程化设计了。</p>
<h3 id="4-里氏代换原则"><a href="#4-里氏代换原则" class="headerlink" title="4.里氏代换原则"></a>4.里氏代换原则</h3><p>里氏代换原则（LSP）：子类型必须能够替换掉他的父类型。说白了就是一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而他察觉不出父类对象和子类对象的区别，也就是说，在软件里面，把父类都替换成他的子类，程序行为没有变化。<br>有了里氏替换原则，才是继承服用成为可能，只有当子类可以替换掉父类时，软件的功能不受到影响，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。<br>有了里氏代换原则，才能使开放-封闭原则成为可能，正是由于子类型的可替换性才使得父类型的模块在无需修改的情况下扩展。</p>
<h3 id="5-接口隔离原则-ISP"><a href="#5-接口隔离原则-ISP" class="headerlink" title="5.接口隔离原则(ISP)"></a>5.接口隔离原则(ISP)</h3><p>接口隔离原则(ISP):不应该强迫客户依赖于它们不用的方法。接口属于客户，不属于它所在的类层次结构。这个说得很明白了，再通俗点说，不要强迫客户使用它们不用的方法，如果强迫用户使用它们不使用的方法，那么这些客户就会面临由于这些不使用的方法的改变所带来的改变。</p>
<h3 id="6-迪米特法则（LoD）"><a href="#6-迪米特法则（LoD）" class="headerlink" title="6.迪米特法则（LoD）"></a>6.迪米特法则（LoD）</h3><p>迪米特法则（Law of Demeter或简写LoD）又叫最少知识原则（Least Knowledge Principle或简写为LKP）:如果两个类不彼此之间直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某个方法的话，可以通过第三者转发这个调用。迪米特法则首先强调的前提是在类的结构设计上，每一个类都应当尽量降低成员的访问权限。迪米特法则其根本思想强调的是类之间的松耦合。类之间的耦合越弱，越利于复用，一个处于弱耦合的类被修改，不会对有关系的类造成波及。</p>
<h3 id="7-合成-聚合复用原则（Composite-Aggregate-Reuse-Principle或CARP）"><a href="#7-合成-聚合复用原则（Composite-Aggregate-Reuse-Principle或CARP）" class="headerlink" title="7.合成/聚合复用原则（Composite/Aggregate Reuse Principle或CARP）"></a>7.合成/聚合复用原则（Composite/Aggregate Reuse Principle或CARP）</h3><p>合成/聚合复用原则（Composite/Aggregate Reuse Principle或CARP）：经常又叫做合成复用原则（Composite Reuse Principle或CRP），就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分；新对象通过向这些对象的委派达到复用已有功能的目的。我白了就是要尽量使用合成/聚合，尽量不要使用继承。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/java-设计模式/">java 设计模式</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-commitallowingstateloss-和commit的区别" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/11/20/commitallowingstateloss-和commit的区别/" class="article-date">
  	<time datetime="2017-11-20T09:23:55.000Z" itemprop="datePublished">2017-11-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/11/20/commitallowingstateloss-和commit的区别/">
        commitallowingstateloss 和commit的区别
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1、什么是FragmentTransaction？"><a href="#1、什么是FragmentTransaction？" class="headerlink" title="1、什么是FragmentTransaction？"></a>1、什么是FragmentTransaction？</h3><p>使用Fragment时，可以通过用户交互来执行一些动作，比如增加、移除、替换等。</p>
<p>所有这些改变构成一个集合，这个集合被叫做一个transaction。</p>
<p>可以调用FragmentTransaction中的方法来处理这个transaction，并且可以将transaction存进由activity管理的back stack中，这样用户就可以进行fragment变化的回退操作。</p>
<p>可以这样得到FragmentTransaction类的实例：</p>
<pre><code>FragmentManager  mFragmentManager = getSupportFragmentManager();

FragmentTransaction  mFragmentTransaction = mFragmentManager.beginTransaction();
</code></pre><h3 id="2、commit和executePendingTransactions的区别"><a href="#2、commit和executePendingTransactions的区别" class="headerlink" title="2、commit和executePendingTransactions的区别"></a>2、commit和executePendingTransactions的区别</h3><p>用add(), remove(), replace()方法，把所有需要的变化加进去，然后调用commit()方法，将这些变化应用。<br>在commit()方法之前，你可以调用addToBackStack()，把这个transaction加入back stack中去，这个back stack是由activity管理的，当用户按返回键时，就会回到上一个fragment的状态。<br>你只能在activity存储它的状态（当用户要离开activity时）之前调用commit()，如果在存储状态之后调用commit()，将会抛出一个异常。<br>这是因为当activity再次被恢复时commit之后的状态将丢失。如果丢失也没关系，那么使用commitAllowingStateLoss()方法。<br>3、问什么在存储状态之后调用commit会报异常？<br>我们查看Android源码发现FragmentManager和FragmentTransaction是一个虚类<br>那他们在activity中的实例化代码是如何处理的呢？<br>首先是getSupportFragmentManager的方法</p>
<pre><code>/**
  * Return the FragmentManager for interacting with fragments associated with this activity.
 */

public FragmentManager getSupportFragmentManager() {

return mFragments;

}
</code></pre><p>查找到mFragments。final FragmentManagerImpl mFragments = new FragmentManagerImpl();<br>我们发现FragmentManagerImpl是继承于FragmentManager的一个实体类<br>view sourceprint?</p>
<pre><code>/**
 * Container for fragments associated with an activity.
 */

final class FragmentManagerImpl extends FragmentManager {


........


@Override
public FragmentTransaction beginTransaction() {
    return new BackStackRecord(this);
}


........


}
</code></pre><p>为了简便我们删除了一些不要的代码只留下关键的方法。<br>通过这段代码，我们可以查看到beginTransaction方法实际返回的是一个继承于FragmentTransaction的BackStackRecord类<br>我们来查看BackStackRecord的代码，查看他的用法</p>
<pre><code>/**
 * @hide Entry of an operation on the fragment back stack.
 */

final class BackStackRecord extends FragmentTransaction implements

FragmentManager.BackStackEntry, Runnable {

    ..........

    public int commit() {

        return commitInternal(false);

    }


    public int commitAllowingStateLoss() {

        return commitInternal(true);

    }


    int commitInternal(boolean allowStateLoss) {

        if (mCommitted) throw new IllegalStateException(&quot;commit already called&quot;);

        if (FragmentManagerImpl.DEBUG) Log.v(TAG, &quot;Commit: &quot; + this);

        mCommitted = true;

        if (mAddToBackStack) {

            mIndex = mManager.allocBackStackIndex(this);

        } else {

        mIndex = -1;

        }

        mManager.enqueueAction(this, allowStateLoss);

        return mIndex;

    }

    ..........

}
</code></pre><p>绕了大半天，终于找到commit方法和commitAllowingStateLoss方法，他们都同时调用了commitInternal方法，只是传的参数略有不同，一个是true，一个是false。我们发现在执行这个方法之前会首先对mCommitted进行判断，根据代码语义我们可以知道mCommitted就是是否已经commit的意思<br>最后，commitInternal调用了mManager.enqueueAction的方法。让我们回到FragmentManager，看这个方法是如何操作的。我们找到这个方法。</p>
<pre><code>public void enqueueAction(Runnable action, boolean allowStateLoss) {
    if (!allowStateLoss) {
        checkStateLoss();
    }
    synchronized (this) {
        if (mDestroyed || mHost == null) {
            throw new IllegalStateException(&quot;Activity has been destroyed&quot;);
        }
        if (mPendingActions == null) {
            mPendingActions = new ArrayList&lt;Runnable&gt;();
        }
        mPendingActions.add(action);
        if (mPendingActions.size() == 1) {
            mHost.getHandler().removeCallbacks(mExecCommit);
            mHost.getHandler().post(mExecCommit);
        }
    }
}
</code></pre><p>经分析后，我们可以发现，此方法在对 commit和commitAllowingStateLoss的传参进行判断后，将任务扔进activity的线程队列中。那这个两个方法区别就在传参判断后的处理方法checkStateLoss，那接下来，让我们查看一下checkStateLoss方法，看对参数进行判断后，做了什么样的处理。</p>
<pre><code>private void checkStateLoss() {

    if (mStateSaved) {
        throw new IllegalStateException(&quot;Can not perform this action after onSaveInstanceState&quot;);
    }    

    if (mNoTransactionsBecause != null) {
        throw new IllegalStateException(&quot;Can not perform this action inside of &quot; + mNoTransactionsBecause);
    }

}
</code></pre><p>ok，到这里，真相总算大明，当使用commit方法时，系统将进行状态判断，如果状态（mStateSaved）已经保存，将发生”Can not perform this action after onSaveInstanceState”错误。<br>如果mNoTransactionsBecause已经存在，将发生”Can not perform this action inside of “ + mNoTransactionsBecause错误</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/标签-源码分析/">标签:源码分析</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
    <article id="post-about-media" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/10/31/about-media/" class="article-date">
  	<time datetime="2017-10-31T08:24:14.000Z" itemprop="datePublished">2017-10-31</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/10/31/about-media/">
        android MediaPlayer使用注意
        
      </a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h6 id="Android的多媒体框架包括支持播放多种常见的媒体类型，使您可以轻松地把音频、视频和图像集成到你的应用。你可以播放音频或视频媒体文件，这些文件是存储在你的应用程序的资源文件中的。应用程序的资源文件可以是文件系统中独立的文件，或通过网络连接获取的一个数据流，所有使用MediaPlayer-APIS的资源文件。"><a href="#Android的多媒体框架包括支持播放多种常见的媒体类型，使您可以轻松地把音频、视频和图像集成到你的应用。你可以播放音频或视频媒体文件，这些文件是存储在你的应用程序的资源文件中的。应用程序的资源文件可以是文件系统中独立的文件，或通过网络连接获取的一个数据流，所有使用MediaPlayer-APIS的资源文件。" class="headerlink" title="Android的多媒体框架包括支持播放多种常见的媒体类型，使您可以轻松地把音频、视频和图像集成到你的应用。你可以播放音频或视频媒体文件，这些文件是存储在你的应用程序的资源文件中的。应用程序的资源文件可以是文件系统中独立的文件，或通过网络连接获取的一个数据流，所有使用MediaPlayer APIS的资源文件。"></a>Android的多媒体框架包括支持播放多种常见的媒体类型，使您可以轻松地把音频、视频和图像集成到你的应用。你可以播放音频或视频媒体文件，这些文件是存储在你的应用程序的资源文件中的。应用程序的资源文件可以是文件系统中独立的文件，或通过网络连接获取的一个数据流，所有使用MediaPlayer APIS的资源文件。</h6><h2 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h2><p>注意：如果你通过一个URL来获取一个在线媒体文件，该文件必须能够支持渐进式下载。</p>
<h2 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h2><p>警告：当你使用setDataSource()方法时，必须捕捉非法数据异常和输入输出异常，因为正在被你引用的文件可能不存在在。</p>
<h2 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h2><p>异步准备 - Asynchronous Preparation<br>使用MediaPlayer 的原则很简单。然而，重要的是要记住，有必要将更多的一些东西正确地集成到一个典型的Android应用程序。比如，调用prepare()方法可能需要较长的时间来执行，因为它可能涉及获取和解码媒体数据。因此，例如这样的任何方法，可能需要很长时间执行，要尽量避免在主线程（UI线程）调用它。因为那样很可能会造成ANR，这样用户体验是很不好的。 所以即使你预期资源能快速加载，但是记住任何超过十分之一秒的反应在界面上会造成明显的停顿，将导致给用户的印象是：你的应用程序是缓慢的。<br>为了避免你的UI线程挂起，产生另一个线程准备MediaPlayer 当完成时通知主线程。你可以写自己的线程的逻辑，框架提供prepareAsync() 方法，方便的使用MediaPlayer 。该方法在后台开始准备媒体并立即返回。当媒体准备好了，MediaPlayer.ONPREPAREDLISTENER的ONPREPARED 方法，通过配置setonpreparedlistener()方法来调用。</p>
<h2 id="4"><a href="#4" class="headerlink" title="4."></a>4.</h2><p>状态管理 - Managing State<br>关于MediaPlayer ，你需要记住的另一点是它的状态。即，在你编写自己的代码的时候，必须时刻意识到MediaPlayer 有一个内部状态，因为只有当播放器在特定状态，某些特定的操作才会有效。如果你在错误的状态执行一个操作，系统可能会抛出一个异常会让用户体验相当不好。<br>MediaPlayer 类里有文件显示一个完整的状态转换图，阐明哪些方法可以把MediaPlayer 从一个状态改变到另一个状态。例如,当您创建一个新的MediaPlayer ,它就处于闲置状态。这时用setDataSource()方法来初始化它，把它设置为初始化状态。然后，必须使用prepare()方法或prepareAsync()方法。当MediaPlayer 准备好了，Mediaplayer将进入准备状态,这也就意味着是时候调用start()方法来播放多媒体。另外，在状态转换图上阐明了，可以调用start(),pause()和 seekTo()这些方法在Started,Paused和PlaybackCompleted状态之间进行转换。如果调用stop()方法,这时请注意需要再次准备MediaPlayer ，才可以再一次调用start()方法。<br>在编写代码与MediaPlayer 对象交互时，心里要随时想着状态转换图，因为从错误的状态调用它的方法,是引起错误的常见原因。<br>释放MediaPlayer-Releasing the MediaPlayer<br>MediaPlayer 会消耗宝贵的系统资源。因此 ，应该经常采取额外的预防措施来确保及时把不需要的MediaPlayer取消掉。需要调用release()方法来确保系统分配给它的资源正确释放。例如,正在使用MediaPlayer调用了onStop()方法，这时必须释放MediaPlayer,因为这时活动并非与用户交互，留着它没什么意义（除非你是在后台播放多媒体）。当活动恢复或者重新启动，恢复播放之前,需要创建一个新的MediaPlayer并且重新准备。<br>下面是释放和取消MediaPlayer的方法:<br>mediaPlayer.release(); mediaPlayer = null;<br>作为思考题，考虑一下如果当活动停止的时候你忘了释放MediaPlayer，活动重启后新建一个MediaPlayer，可能会发生的问题。正如你可能知道的，当用户更改屏幕的方向（或以另一种方式更改设备配置），该系统通过重启活动处理（通过默认方式），所以当用户频繁在纵向和横向之间切换时，你可能会很快消耗掉所有的系统资源，原因是你没有释放方向变化时各个方向上创建的新MediaPlayer。(更多关于运行时重启的资料,请查看Handling Runtime Changes)。<br>你可能会想知道在用户离开活动时后台继续播放媒体是如何实现的，采用同样的方式实现的，如内置的音乐应用程序的行为。在这种情况下,你需要通过一个Service来控制MediaPlayer，所以我们开始学习Using a Service with MediaPlayer。</p>
<h2 id="5"><a href="#5" class="headerlink" title="5."></a>5.</h2><p> 使用服务控制MediaPlayer - Using a Service with MediaPlayer<br>如果你希望后台播放媒体，你希望用户操作其他应用时继续播放，你必须开始一个Service并且从那里控制MediaPlayer实例。你必须慎重考虑这个设置，因为用户与系统期望应用程序运行的后台服务应该与系统的其余部分相互作用。如果应用程序不满足这些预期，就不能有良好的用户体验。本节介绍的主要内容是：告诉你相关知识，并提供建议如何接触它们。<br>异步运行 - Running asynchronously<br>首先,如一个Activity,服务里的所有任务默认在单一线程中完成。如果你从同一个应用程序里运行一个Activity和一个Service，它们默认使用相同的线程(“主线程”)。因此，Service需要迅速处理传入的意图并且响应它们的时候从不执行冗长的计算。如果预计调用一些复杂的任务或阻塞，你必须异步处理这些任务：由另一个线程自己实现自己，或使用框架处理异步。<br>例如，当你从主要线程使用一个MediaPlayer ，你应该调用prepareAsync()方法而不是prepare() 方法，实现MediaPlayer.OnPreparedListener，以便当你准备工作完毕后，得到可以开始播放的通知。<br>代码如下：</p>
<pre><code>public class MyService extends Service implements MediaPlayer.OnPreparedListener { 

    private static final ACTION_PLAY = &quot;com.example.action.PLAY&quot;; 

     MediaPlayer mMediaPlayer = null;

      public int onStartCommand(Intent intent, int flags, int startId) { 
    ... if (intent.getAction().equals(ACTION_PLAY)){
             mMediaPlayer = ... // initialize it here
             mMediaPlayer.setOnPreparedListener(this); 
             mMediaPlayer.prepareAsync(); // prepare async to not block main thread 
          }
    } 

      public void onPrepared(MediaPlayer player){

        player.start();

     } 
  }
</code></pre><p>处理异步错误 - Handling asynchronous errors<br>在同步操作中,错误通常会出现异常或错误代码信息。但当你使用异步资源时，您需要确保您的应用程序有错误提示，在MediaPlayer 中，要做到这一点，可以通过实现MediaPlayer.OnErrorListener，并且将它设置在你的MediaPlayer 实体中。</p>
<pre><code>public class MyService extends Service implements MediaPlayer.OnErrorListener { 
    MediaPlayer mMediaPlayer; public void initMediaPlayer() {
     // ...initialize the MediaPlayer here...  
     mMediaPlayer.setOnErrorListener(this); 
    } 

    @Override public boolean onError(MediaPlayer mp, int what, int extra) {
     // ... react appropriately ... // The MediaPlayer has moved to the Error state, must be reset! 
    }
 }
</code></pre><p>请牢记,当出现错误，将这个MediaPlayer 设置为错误状态（请参考MediaPlayer 类文档的完整的状态关系图）您再次使用它之前，必须重置这个状态。<br>使用唤醒锁 - Using wake locks<br>应用程序在后台播放媒体，其服务在运行期间，设备可能会进入休眠状态。因为Android系统希望在设备休眠时节省电池。系统试图关闭手机的应用程序,是没有必要的，包括CPU和WiFi硬件。但是，如果你的服务正在运行或播放着音乐，你希望防止系统干扰你的回放。<br>为了确保您的服务在这些条件下能继续运行，你需要使用“wake locks”。唤醒锁是一种信号系统，它发出信号,显示：应用程序正在使用或可用的功能，或手机闲置。<br>注意:你应该尽量少用唤醒锁，只有在必要时候才使用它们。它们会使设备的电池寿命大大降低。<br>你MediaPlayer 正在播放时，需要确保CPU持续运行，当初始化你的MediaPlayer时，调用setWakeMode()方法。一旦你这样做了,当暂停或停止时候，MediaPlayer 持有指定的锁：</p>
<pre><code>mMediaPlayer = new MediaPlayer(); // ... other initialization here ... mMediaPlayer.setWakeMode(getApplicationContext(), PowerManager.PARTIAL_WAKE_LOCK);
</code></pre><p>在这个例子中获得唤醒锁是指在保证CPU在唤醒状态。当你通过网络获取媒体和您正在使用WiFi时,你可能希望有个WifiLock，可以手动获取并释放。当你开始通过远程URL准备MediaPlayer，你应该创建并获得wi - fi锁。 代码如下：</p>
<pre><code>WifiLock wifiLock = ((WifiManager) getSystemService(Context.WIFI_SERVICE)) .createWifiLock(WifiManager.WIFI_MODE_FULL, &quot;mylock&quot;); wifiLock.acquire();
</code></pre><p>当你暂停或停止你的媒体时,或当你不再需要这样的网络,你应该释放该锁: 代码如下：</p>
<pre><code>wifiLock.release();
</code></pre><p>作为前景服务运行 - Running as a foreground service<br>服务通常用于执行后台任务，例如获取电子邮件，同步数据，下载内容,或其他。在这些情况下,用户不会意识到这个服务的执行，甚至可能不会注意到这些服务被打断,后来重新启动。毫无疑问，后台播放音乐是一个服务，用户能意识到，任何中断都会严重影响到用户体验。此外，用户可能会希望在这个服务执行期间作用于它。这种情况，服务应该运行一个“前景服务”。前台服务在系统中持有一个更高水平的重要性，系统几乎从未将服务扼杀，因为它对用户有着直接的重要性。当应用在前台运行，该服务还必须提供一个状态栏来通知用户意识有服务正在运行同时允许他们打开一个活动,可以与服务进行交互。<br>为了把你的服务变为前景服务，您必须为状态栏创建一个Notification，并且从Service调用startForeground()方法。<br>代码如下:</p>
<pre><code>String songName; // assign the song name to songNamePendingIntent pi = PendingIntent.getActivity(getApplicationContext(), 0, new Intent(getApplicationContext(), MainActivity.class), PendingIntent.FLAG_UPDATE_CURRENT); Notification notification = new Notification();
 notification.tickerText = text; notification.icon = R.drawable.play0; 
notification.flags |= Notification.FLAG_ONGOING_EVENT; 
notification.setLatestEventInfo(getApplicationContext(), &quot;MusicPlayerSample&quot;, &quot;Playing: &quot; + songName, pi); startForeground(NOTIFICATION_ID, notification);
</code></pre><p>通知区域可见的设备告诉你，服务在前台运行。如果用户选择了这个通知，系统将调用你提供的PendingIntent。在上面的例子中，它打开了一个Activity。（MainActivity）<br>图1显示了如何将通知呈现给用户:<br> Img1.png        Img2.png<br>图1:界面的一个前景服务通知,如上图，显示通知图标(在左)、扩展视图(在右)。<br>实际执行一些用户能够意识到的服务时，你应该保留“foreground service”的状态。相反情况下，你应该调用stopForeground()方法来释放它。 代码如下：</p>
<pre><code>stopForeground(true);
</code></pre><p>更多信息，请参考Service和 Status Bar Notifications的相关文档。</p>
<h2 id="处理音频焦点-Handling-audio-focus"><a href="#处理音频焦点-Handling-audio-focus" class="headerlink" title="处理音频焦点 - Handling audio focus="></a>处理音频焦点 - Handling audio focus=</h2><p>在给定的时间尽管只有一个活动可以运行,但Android是一个多任务环境。这对应用程序使用音频 造成了一个特别大的难度，由于只有一个音频输出,可能会有好几个媒体服务争夺使用它。Android 2.2之前,没有内置机制来解决这个问题，这可能在某些情况下导致糟糕的用户体验。例如，一个用户正在听音乐，同时，另一个应用程序有很重要的事需要通知用户，由于吵闹的音乐用户可能不会听到提示音。从Android 2.2开始,Android平台为应用程序提供了一个方式来协商设备的音频输出。这个机制被称为音频焦点。<br>当您的应用程序需要输出音频如音乐或一个通知,这时你就必须请求音频焦点。一旦得到焦点，它就可以自由的使用声音输出设备，同时它会不断监听焦点的更改。如果它被通知已经失去了音频焦点，它会要么立即杀死音频或立即降低到一个安静的水平（被称为“ducking”——有一个标记,指示哪一个是适当的）当它再次接收焦点时，继续不断播放。<br>音频焦点是自然的合作。应用程序都期望（强烈鼓励）遵守音频焦点指南，但规则并不是系统强制执行的。如果应用程序失去音频焦点后想要播放嘈杂的音乐，在系统中没有什么会阻止他。然而,这样可能会让用户有更糟糕的体验,并可能卸载这运行不当的应用程序。<br>请求音频焦点,您必须从AudioManager调用requestAudioFocus()方法，下面展示一个例子：</p>
<pre><code>AudioManager audioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE); 
int result = audioManager.requestAudioFocus(this, AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN);   
if (result != AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {
 // could not get audio focus.}
</code></pre><p>requestAudioFocus()的第一个参数是AudioManager.OnAudioFocusChangeListener，每当音频焦点有变动的时候其onAudioFocusChange()方法被调用。您还应该在你的服务和活动上实现这个接口。<br>代码如下：</p>
<pre><code>class MyService extends Service implements AudioManager.OnAudioFocusChangeListener { 
    // .... public void onAudioFocusChange(int focusChange) {
     // Do something based on focus change... 
    }
 }
</code></pre><p>focusChange 参数告诉你音频焦点是如何改变的，并且可以使用以下的值之一（他们都是在AudioManager中定义常量的）：<br>AUDIOFOCUS_GAIN: 你已经得到了音频焦点。<br>AUDIOFOCUS_LOSS: 你已经失去了音频焦点很长时间了。你必须停止所有的音频播放。因为你应该不希望长时间等待焦点返回，这将是你尽可能清除你的资源的一个好地方。例如，你应该释放MediaPlayer。<br>AUDIOFOCUS_LOSS_TRANSIENT:你暂时失去了音频焦点，但很快会重新得到焦点。你必须停止所有的音频播放，但是你可以保持你的资源，因为你可能很快会重新获得焦点。<br>AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK: 你暂时失去了音频焦点，但你可以小声地继续播放音频（低音量）而不是完全扼杀音频。<br>下面是一个示例实现：</p>
<pre><code>public void onAudioFocusChange(int focusChange) { 

    switch (focusChange) {
         case AudioManager.AUDIOFOCUS_GAIN: // resume playback
        if (mMediaPlayer == null) 
            initMediaPlayer(); 
        else if (!mMediaPlayer.isPlaying())
             mMediaPlayer.start(); 
        mMediaPlayer.setVolume(1.0f, 1.0f); 
        break; 
    case AudioManager.AUDIOFOCUS_LOSS: // Lost focus for an unbounded amount of time: stop playback and release media player 
        if (mMediaPlayer.isPlaying()) {
            mMediaPlayer.stop(); 
            mMediaPlayer.release(); 
            mMediaPlayer = null; 
        }
        break;
     case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT: // Lost focus for a short time, but we have to stop // playback. We don&apos;t release the media player because playback // is likely to resume 
        if (mMediaPlayer.isPlaying()) 
            mMediaPlayer.pause(); 
            break;
     case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK: // Lost focus for a short time, but it&apos;s ok to keep playing // at an attenuated level 
        if (mMediaPlayer.isPlaying()) 
            mMediaPlayer.setVolume(0.1f, 0.1f);
        break;
         }
     }
</code></pre><p>记住,音频焦点APIs在API级别8(Android 2.2)及以上才有效。所以如果你想要支持的以前版本的Android，(如果有的话)你应该采取一种向后兼容性策略,允许您使用该特性，（如果没有的话），只能选择8以后的版本。<br>通过反射调用音频焦点方法或通过在一个单独类中实现所有的音频焦点特性，您可以实现向后兼容性（AudioFocusHelper 中阐明）。下面是这样一个类的示例:</p>
<pre><code>public class AudioFocusHelper implements AudioManager.OnAudioFocusChangeListener {
     AudioManager mAudioManager; // other fields here, you&apos;ll probably hold a reference to an interface // that you can use to communicate the focus changes to your Service   

     public AudioFocusHelper(Context ctx, ) {
         mAudioManager = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE); 
        // ... 
     }

     public boolean requestFocus() {
         return AudioManager.AUDIOFOCUS_REQUEST_GRANTED == mAudioManager.requestAudioFocus(mContext, AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN);
     }   

     public boolean abandonFocus() { 
         return AudioManager.AUDIOFOCUS_REQUEST_GRANTED == mAudioManager.abandonAudioFocus(this); 
     }

     @Override public void onAudioFocusChange(int focusChange) { 
        // let your service know about the focus change 
     }
 }
</code></pre><p>当你发现系统运行时API级别在8级或以上时，您可以创建AudioFocusHelper 类的一个实例，例如：</p>
<pre><code>if (android.os.Build.VERSION.SDK_INT &gt;= 8) { 
    mAudioFocusHelper = new AudioFocusHelper(getApplicationContext(), this);
 } else {
    mAudioFocusHelper = null; 
 }
</code></pre><p>执行清理 - Performing cleanup<br>正如前面所提到的,MediaPlayer 对象会消耗大量的系统资源，所以你可以在你需要用他的时候保留他，当你不需要他的时候调用release() 方法。调用这个显式地清除方法是重要的，而不是依赖于系统的垃圾收集，因为它可能需要一些时间垃圾收集器才能收回MediaPlayer ，因为这只是内存敏感的需求而不是其他媒体资源的短缺。既然如此，当你使用一个服务时，你应该覆盖onDestroy()方法，来确定你的MediaPlayer释放了。<br>代码如下：</p>
<pre><code>  public class MyService extends Service {

    MediaPlayer mMediaPlayer; // ...   

    @Override public void onDestroy() {
         if (mMediaPlayer != null) 
         mMediaPlayer.release(); 
    }
}
</code></pre><p>你最好始终寻找其它机会来释放你的MediaPlayer，关闭的时候就释放掉。例如，如果你期望较长的一段时间不能够播放媒体（例如，失去音频焦点后），你肯定得先释放你现有的MediaPlayer ，以后要用的时候再创建它。另一方面,如果你只希望停止播放很短的一段时间,你应该尽量保留你的MediaPlayer，以免花费时间重新创建和准备一遍。<br>处理AUDIO_BECOMING_NOISY意图-Handling the AUDIO_BECOMING_NOISY Intent许多编写良好的应用程序有以下特点，当一个事件导致音频变得聒噪时，自动停止音频播放。(通过外部扬声器输出)。例如,一个用户戴着耳机听音乐，可能会不小心切断耳机和设备的链接。虽然,这种行为不会自动发生。如果您没有实现这个特性，设备的外部扬声器会将音频播放出来，这可能是用户不希望发生的。<br>这些情况下通过处理ACTION_AUDIO_BECOMING_NOISY意图，可以让你的应用程序停止播放音乐，通过在你的manifest里添加以下代码，你可以注册一个接收器：<br>“.MusicIntentReceiver”&gt; “android.media.AUDIO_BECOMING_NOISY” /&gt;<br>注册MusicIntentReceiver 类当作一个广播接收器的意图，然后您应该实现这类，代码如下:</p>
<pre><code>public class MusicIntentReceiver implements android.content.BroadcastReceiver {

     @Override public void onReceive(Context ctx, Intent intent) { 
        if (intent.getAction().equals( android.media.AudioManager.ACTION_AUDIO_BECOMING_NOISY)) {
             // signal your service to stop playback // (via an Intent, for instance) 
        }
     }
 }
</code></pre><p>从内容解析器检索媒体 - Retrieving Media from a Content Resolver<br>在媒体播放器应用程序中，另一个可能有用的特性是用户可以在设备上检索音乐。你可以通过为外部媒体查询ContentResolver，代码如下：</p>
<pre><code>ContentResolver contentResolver = getContentResolver(); 
Uri uri = android.provider.MediaStore.Audio.Media.EXTERNAL_CONTENT_URI; 
Cursor cursor = contentResolver.query(uri, null, null, null, null); 
if (cursor == null) { 
    // query failed, handle error.
} else if (!cursor.moveToFirst()) { 
    // no media on the device 
} else { 
    int titleColumn = cursor.getColumnIndex(android.provider.MediaStore.Audio.Media.TITLE);
       int idColumn = cursor.getColumnIndex(android.provider.MediaStore.Audio.Media._ID); 
do { 
    long thisId = cursor.getLong(idColumn); 
    String thisTitle = cursor.getString(titleColumn); // ...process entry... 
    } while (cursor.moveToNext()); 
}
</code></pre><p>要和MediaPlayer一起使用,你可以这样做,代码如下:</p>
<pre><code>long id = ;
Uri contentUri = ContentUris.withAppendedId( android.provider.MediaStore.Audio.Media.EXTERNAL_CONTENT_URI, id); 
mMediaPlayer = new MediaPlayer(); 
mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC); 
mMediaPlayer.setDataSource(getApplicationContext(), contentUri);
</code></pre>
      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/android-mediaplayer-视频-音频/">android mediaplayer 视频 音频</a></li></ul>
	</div>

      

      
      <div class="clearfix"></div>
    </div>
      
    
  </div>
  
</article>







  
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2018 silenceyixia
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>